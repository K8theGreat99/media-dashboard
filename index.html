<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Media Dashboard</title>
    <style>
        :root {
            /* Light Theme (Default) */
            --primary: #2c3e50;
            --secondary: #3498db;
            --accent: #e74c3c;
            --background: #ecf0f1;
            --card-bg: #ffffff;
            --text: #2c3e50;
            --text-light: #7f8c8d;
            --border: #bdc3c7;
            --success: #27ae60;
            --modal-overlay: rgba(0, 0, 0, 0.5);
        }

        [data-theme="dark"] {
            /* Dark Theme */
            --primary: #ecf0f1;
            --secondary: #3498db;
            --accent: #e74c3c;
            --background: #1a1a1a;
            --card-bg: #2c3e50;
            --text: #ecf0f1;
            --text-light: #bdc3c7;
            --border: #4a6278;
            --success: #2ecc71;
            --modal-overlay: rgba(0, 0, 0, 0.7);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: var(--background);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid var(--secondary);
            position: relative;
        }

        .header-buttons {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 8px;
        }

        h1 {
            font-size: 2.5em;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .tagline {
            font-size: 1.2em;
            color: var(--text-light);
            font-style: italic;
        }

        /* Icon button base style */
        .icon-btn {
            position: relative;
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-light);
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn:hover {
            background: var(--border);
            color: var(--text);
        }

        /* CSS Tooltip */
        .icon-btn::after {
            content: attr(data-tooltip);
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
            padding: 6px 10px;
            background: var(--primary);
            color: var(--background);
            font-size: 0.75em;
            border-radius: 4px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            z-index: 100;
        }

        /* Tooltip arrow */
        .icon-btn::before {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 3px;
            border: 5px solid transparent;
            border-bottom-color: var(--primary);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            z-index: 100;
        }

        .icon-btn:hover::after,
        .icon-btn:hover::before {
            opacity: 1;
            visibility: visible;
        }

        .section {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border);
        }

        h2 {
            font-size: 1.8em;
            color: var(--primary);
        }

        .refresh-btn {
            background: transparent;
            color: var(--text-light);
            border: 1px solid var(--border);
            width: 40px;
            height: 40px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2em;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-btn:hover {
            background: var(--border);
            color: var(--text);
            transform: translateY(-2px);
        }

        .refresh-btn:disabled {
            background: var(--border);
            cursor: not-allowed;
            transform: none;
            opacity: 0.5;
        }

        /* Currently Reading Section */
        .reading-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .book-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            border-radius: 10px;
            color: white;
            cursor: pointer;
        }

        .book-card h3 {
            margin-bottom: 5px;
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .book-title {
            font-size: 1.3em;
            margin-bottom: 15px;
            font-weight: 600;
        }

        .book-link {
            display: inline-block;
            background: white;
            color: #667eea;
            padding: 10px 20px;
            border-radius: 6px;
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s;
        }

        .book-link:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .add-book-btn {
            background: var(--success);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 15px;
            transition: all 0.3s;
        }

        .add-book-btn:hover {
            background: #229954;
            transform: translateY(-2px);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--card-bg);
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
        }

        .modal-content h3 {
            margin-bottom: 20px;
            color: var(--primary);
        }

        .modal-content p {
            margin-bottom: 15px;
            color: var(--text-light);
            font-size: 0.95em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text);
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 1em;
            background: var(--background);
            color: var(--text);
        }

        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--secondary);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 25px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--secondary);
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text);
        }

        .btn-secondary:hover {
            background: #95a5a6;
        }

        .btn-danger {
            background: var(--accent);
            color: white;
            font-size: 0.85em;
            padding: 8px 16px;
            margin-top: 10px;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        /* Content Feed Items */
        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 20px;
        }

        .content-card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.3s;
        }

        .content-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .content-card img {
            width: 100%;
            height: 180px;
            object-fit: cover;
        }

        .thumbnail-container {
            position: relative;
        }

        .duration-badge {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 500;
        }

        .content-card-body {
            padding: 15px;
        }

        .content-card h3 {
            font-size: 1.1em;
            margin-bottom: 8px;
            color: var(--primary);
            line-height: 1.4;
        }

        .content-card a {
            color: var(--primary);
            text-decoration: none;
        }

        .content-card a:hover {
            color: var(--secondary);
        }

        .content-meta {
            color: var(--text-light);
            font-size: 0.85em;
            margin-top: 8px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-light);
            font-style: italic;
        }

        .error {
            background: #ffe6e6;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-light);
        }

        .empty-state p {
            margin-bottom: 20px;
        }

        /* Archive System */
        .content-card {
            position: relative;
        }

        .archive-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s, background 0.2s;
            z-index: 10;
        }

        .content-card:hover .archive-btn {
            opacity: 1;
        }

        .archive-btn:hover {
            background: var(--accent);
        }

        .content-card.archived {
            opacity: 0.4;
            filter: grayscale(70%);
            cursor: pointer;
        }

        .content-card.archived a {
            pointer-events: none;
        }

        .content-card.archived .archive-btn {
            display: none;
        }

        .content-card.archived::after {
            content: 'Click to restore';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 0.85em;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .content-card.archived:hover::after {
            opacity: 1;
        }

        .api-status {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75em;
            margin-left: 10px;
            vertical-align: middle;
        }

        .api-status.configured {
            background: #d4edda;
            color: #155724;
        }

        .api-status.missing {
            background: #fff3cd;
            color: #856404;
        }

        .cache-info {
            display: flex;
            align-items: center;
            gap: 20px;
            font-size: 0.85em;
            color: var(--text-light);
        }

        .cache-time {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .refresh-counter {
            color: var(--text-light);
            font-size: 0.85em;
        }

        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: var(--text-light);
            font-size: 0.8em;
            border-top: 1px solid var(--border);
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <div class="header-buttons">
                <button class="icon-btn" onclick="toggleTheme()" id="theme-toggle-btn" data-tooltip="Dark Mode">
                    <span id="theme-icon">üåô</span>
                </button>
                <button class="icon-btn" onclick="openApiKeyModal()" data-tooltip="Settings">
                    ‚öôÔ∏è
                </button>
            </div>
            <h1>‚òÆÔ∏è Media Dashboard</h1>
            <p class="tagline">Intentional content, curated by you</p>
        </header>

        <!-- Currently Reading/Listening Section -->
        <section class="section">
            <div class="section-header">
                <h2>Currently Reading & Listening</h2>
            </div>
            <div class="reading-grid" id="reading-grid">
                <!-- Books will be added here -->
            </div>
            <button class="add-book-btn" onclick="openBookModal()">+ Add Book/Audiobook</button>
        </section>

        <!-- YouTube Section -->
        <section class="section">
            <div class="section-header">
                <h2>üì∫ Latest from YouTube <span id="youtube-api-status" class="api-status"></span></h2>
                <div class="cache-info">
                    <span class="cache-time" id="cache-time">Last updated: Never</span>
                    <span class="refresh-counter" id="refresh-counter">Refreshes: 0</span>
                </div>
                <button class="refresh-btn" onclick="refreshYouTube()" id="youtube-refresh">‚Üª</button>
            </div>
            <div id="youtube-content">
                <div class="loading">Loading videos...</div>
            </div>
        </section>

        <!-- Substack Section -->
        <section class="section">
            <div class="section-header">
                <h2>‚úçÔ∏è Latest from Substack</h2>
                <button class="refresh-btn" onclick="refreshSubstack()" id="substack-refresh">‚Üª</button>
            </div>
            <div id="substack-content">
                <div class="loading">Loading articles...</div>
            </div>
        </section>

        <footer>
            version: compost 5
        </footer>
    </div>

    <!-- Add/Edit Book Modal -->
    <div class="modal" id="bookModal">
        <div class="modal-content">
            <h3 id="book-modal-title">Add Book/Audiobook</h3>
            <form id="bookForm">
                <div class="form-group">
                    <label for="platform">Platform</label>
                    <select id="platform" required>
                        <option value="Audible">Audible</option>
                        <option value="Kindle">Kindle</option>
                        <option value="Kobo">Kobo</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="title">Book Title</label>
                    <input type="text" id="title" required placeholder="Enter book title">
                </div>
                <div class="form-group">
                    <label for="url">URL (link to book page)</label>
                    <input type="url" id="url" required placeholder="https://...">
                </div>
                <div class="modal-buttons">
                    <button type="button" class="btn btn-secondary" onclick="closeBookModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save</button>
                </div>
            </form>
            <button class="btn btn-danger" id="deleteBtn" style="display: none;" onclick="deleteCurrentBook()">Delete
                Book</button>
        </div>
    </div>

    <!-- API Key Setup Modal -->
    <div class="modal" id="apiKeyModal">
        <div class="modal-content">
            <h3>üîë API Key Setup</h3>

            <form id="apiKeyForm">
                <div class="form-group">
                    <label for="apiKey">YouTube Data API Key</label>
                    <input type="text" id="apiKey" placeholder="AIzaSy...">
                    <p style="font-size: 0.8em; color: var(--text-light); margin-top: 5px;">
                        Required for YouTube videos. stored locally.
                    </p>
                </div>

                <div class="form-group"
                    style="margin-top: 20px; border-top: 1px solid var(--border); padding-top: 20px;">
                    <label for="rssApiKey">RSS2JSON API Key (Optional)</label>
                    <input type="text" id="rssApiKey" placeholder="Enter key if feeds fail...">
                    <p style="font-size: 0.8em; color: var(--text-light); margin-top: 5px;">
                        Optional. Get a free key from <a href="https://rss2json.com/apikey" target="_blank"
                            style="color: var(--secondary);">rss2json.com</a> if you hit rate limits (429 errors).
                    </p>
                </div>

                <div class="modal-buttons">
                    <button type="button" class="btn btn-secondary" onclick="closeApiKeyModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Save Keys</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIGURATION - YOUR PERSONALIZED SETTINGS
        // ============================================

        const CONFIG = {
            // Your YouTube Uploads Playlist IDs (converted from channel IDs: UC -> UU)
            youtubePlaylistIds: [
                'UU8JOgFXp-I3YV6dsKqqQdUw',  // Caroline Winkler
                'UU13w4dxfIGf_MM2qtyJ1aSA',  // Christy Anne Jones
                'UUC0FFiHb6mSNKf4h455G0Gw',  // Everyday People do Business and Money
                'UUnhpSiQ1iBJbt_euYU9myxA',  // Anna Howard
                'UUk9Nz_upeYXu2DpEvs1HajQ',  // Snapdragon Life
                'UUvnSyOfwtn7J14CYRbCaveQ',  // Rajiv Surendra
                'UUSHtaUm-FjUps090S7crO4Q',  // Bernadette Banner
                'UUoydhtfFSk1fZXNRnkGnneQ',  // ESOTERICA
                'UUSwwoUNvQWgZDC8a_O6Qs_A',  // Kaz Rowe
                'UUgz4oLdeKP1Pt2BpiUn2iXQ',  // V. Birchwood
                'UUca-WkVPVe9nzs2iFct4wxg',  // Nicole Rudolph
                'UU-SrCCzkGq0wmSAuRs7EBFg',  // Miniminuteman
                'UUehBVAPy-bxmnbNARF-_tvA',  // More Perfect Union
                'UUl05spNa1YKRfSnQyIdCxfg',  // The Cozy Creative
                'UUbRP3c757lWg9M-U7TyEkXA',  // Theo - t3‚Ä§gg
                'UUhpleBmo18P08aKCIgti38g',  // Matt Wolfe
                'UUqcbQf6yw5KzRoDDcZ_wBSw',  // Wes Roth
                'UU5l7RouTQ60oUjLjt1Nh-UQ',  // AI Revolution
                'UUIHKqzULI6b8yrfOV3uCx7A',  // endeavorance
                'UUlFSU9_bUb4Rc6OYfTt5SPw',  // Philip DeFranco
                'UU4e3Gm46D6hWqVyjwkgS33g',  // Under The Desk News
                'UUpa-Zb0ZcQjTCPP1Dx_1M8Q',  // LegalEagle
                'UUwWhs_6x42TyRM4Wstoq8HA',  // The Daily Show
                'UUMtFAi84ehTSYSE9XoHefig',  // The Late Show with Stephen Colbert
                'UUJHAT3Uvv-g3I8H3GhHWV7w',  // Ryan Hall, Y'all
                'UUT6Y5JJPKe_JDMivpKgVXew',  // Fall of Civilizations
                'UU22uGvImj3o7m9Zf11jEDkg',  // Cambrian Chronicles
                'UUUVwT8zcS5Z_rYXnpomlbfg',  // Dan Davis History
                'UUqUCj6qGiqnvSeBZCdfHUmQ',  // Rita Wilkins
                'UUZdWrz8pF6B5Y_c6Zi6pmdQ',  // Decoding the Unknown
                'UUergKLoy-Yv9zlPk3XQYK7Q',  // Crashing Out with Philip DeFranco & Alex Pearlman
            ],

            // Your Substack Newsletter URLs
            substackFeeds: [
                'https://dominiquetaylor.substack.com',
                'https://dannberg.substack.com',
                'https://dhimmimonde.substack.com',
                'https://petersmetanick.substack.com',
                'https://sparrowsendclubhouse.substack.com',
                'https://foxhollowfarm.substack.com',
                'https://rubyleighmccray.substack.com',
                'https://amandanbray.substack.com',
                'https://jessliese.substack.com',
                'https://joyfulordinary.substack.com',
                'https://jtlawrence.substack.com',
                'https://mogginbogginsalmanac.substack.com',
                'https://lewright.substack.com',
                'https://lidiyafoxglove.substack.com',
                'https://tjpatton.substack.com',
                'https://madebyma.substack.com',
                'https://runamukacres.substack.com',
                'https://7figurefiction.substack.com',
                'https://on.substack.com',
                'https://penandprosper.substack.com',
                'https://www.personalcanon.com',
                'https://deeprootscommunity.substack.com',
                'https://thetenderroom.substack.com',
                'https://unfinishedsketchbook.substack.com',
                'https://zyntale.substack.com',
            ],

            // Number of items to show per feed
            maxVideos: 15,
            maxArticles: 15,

            // Cache size (store more than we display to account for archived items)
            cacheVideos: 50,
            cacheArticles: 50,

            // Minimum video duration in seconds (filters out Shorts)
            // 120 = 2 minutes
            minVideoDuration: 120
        };

        // ============================================
        // THEME MANAGEMENT
        // ============================================

        const THEME_STORAGE_KEY = 'media_dashboard_theme';

        function getSavedTheme() {
            return localStorage.getItem(THEME_STORAGE_KEY) || 'light';
        }

        function applyTheme(theme) {
            const root = document.documentElement;
            const toggleBtn = document.getElementById('theme-toggle-btn');
            const toggleIcon = document.getElementById('theme-icon');

            if (theme === 'dark') {
                root.setAttribute('data-theme', 'dark');
                toggleIcon.textContent = '‚òÄÔ∏è';
                toggleBtn.setAttribute('data-tooltip', 'Light Mode');
            } else {
                root.removeAttribute('data-theme');
                toggleIcon.textContent = 'üåô';
                toggleBtn.setAttribute('data-tooltip', 'Dark Mode');
            }

            localStorage.setItem(THEME_STORAGE_KEY, theme);
        }

        function toggleTheme() {
            const currentTheme = getSavedTheme();
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
        }

        // Initialize Theme
        applyTheme(getSavedTheme());

        // ============================================
        // API KEY MANAGEMENT (localStorage)
        // ============================================

        const API_KEY_STORAGE = 'youtube_api_key';
        const RSS_API_KEY_STORAGE = 'rss_api_key';

        function getApiKey() {
            return localStorage.getItem(API_KEY_STORAGE);
        }

        function getRssApiKey() {
            return localStorage.getItem(RSS_API_KEY_STORAGE);
        }

        function setApiKey(key) {
            localStorage.setItem(API_KEY_STORAGE, key);
        }

        function setRssApiKey(key) {
            localStorage.setItem(RSS_API_KEY_STORAGE, key);
        }

        function updateApiKeyStatus() {
            const statusEl = document.getElementById('youtube-api-status');
            const apiKey = getApiKey();

            if (apiKey) {
                statusEl.className = 'api-status configured';
                statusEl.textContent = '‚úì API Key Set';
            } else {
                statusEl.className = 'api-status missing';
                statusEl.textContent = '‚ö† No API Key';
            }
        }

        function openApiKeyModal() {
            const currentKey = getApiKey();
            const currentRssKey = getRssApiKey();
            document.getElementById('apiKey').value = currentKey || '';
            document.getElementById('rssApiKey').value = currentRssKey || '';
            document.getElementById('apiKeyModal').classList.add('active');
        }

        function closeApiKeyModal() {
            document.getElementById('apiKeyModal').classList.remove('active');
        }

        document.getElementById('apiKeyForm').addEventListener('submit', function (e) {
            e.preventDefault();
            const key = document.getElementById('apiKey').value.trim();
            const rssKey = document.getElementById('rssApiKey').value.trim();

            if (key) {
                setApiKey(key);
                updateApiKeyStatus();
            }

            if (rssKey) {
                setRssApiKey(rssKey);
            }

            closeApiKeyModal();
            // Reload content with new keys
            if (key) fetchYouTubeVideos();
            if (rssKey) fetchSubstackArticles(true);
        });

        // Close API modal when clicking outside
        document.getElementById('apiKeyModal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeApiKeyModal();
            }
        });

        // ============================================
        // YOUTUBE CACHING SYSTEM
        // ============================================

        const CACHE_KEYS = {
            videos: 'youtube_cache_videos',
            timestamp: 'youtube_cache_timestamp',
            refreshCount: 'youtube_refresh_count',
            refreshDate: 'youtube_refresh_date',
            // Substack Cache
            articles: 'substack_cache_articles',
            articlesTimestamp: 'substack_cache_timestamp',
            // Archive System
            archivedItems: 'archived_items'
        };

        const CACHE_MAX_AGE_HOURS = 24;
        const MAX_DAILY_REFRESHES = 3;

        // Get current date in Pacific timezone for quota reset alignment
        // YouTube quota resets at midnight Pacific (3 AM Eastern)
        function getPacificDateString() {
            const now = new Date();
            // Get Pacific time by using toLocaleString with timezone
            const pacificString = now.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' });
            const pacificDate = new Date(pacificString);
            return pacificDate.toDateString();
        }

        function saveToCache(videos) {
            localStorage.setItem(CACHE_KEYS.videos, JSON.stringify(videos));
            localStorage.setItem(CACHE_KEYS.timestamp, Date.now().toString());
        }

        function loadFromCache() {
            const cached = localStorage.getItem(CACHE_KEYS.videos);
            return cached ? JSON.parse(cached) : null;
        }

        function getCacheTimestamp() {
            const ts = localStorage.getItem(CACHE_KEYS.timestamp);
            return ts ? parseInt(ts, 10) : null;
        }

        function getCacheAgeHours() {
            const timestamp = getCacheTimestamp();
            if (!timestamp) return Infinity;
            return (Date.now() - timestamp) / (1000 * 60 * 60);
        }

        function isCacheValid() {
            const videos = loadFromCache();
            const ageHours = getCacheAgeHours();
            return videos && videos.length > 0 && ageHours < CACHE_MAX_AGE_HOURS;
        }

        function getRefreshCount() {
            const savedDate = localStorage.getItem(CACHE_KEYS.refreshDate);
            const currentPacificDate = getPacificDateString();

            // Reset counter if it's a new day in Pacific time
            if (savedDate !== currentPacificDate) {
                localStorage.setItem(CACHE_KEYS.refreshDate, currentPacificDate);
                localStorage.setItem(CACHE_KEYS.refreshCount, '0');
                return 0;
            }

            return parseInt(localStorage.getItem(CACHE_KEYS.refreshCount) || '0', 10);
        }

        function incrementRefreshCount() {
            const currentPacificDate = getPacificDateString();
            localStorage.setItem(CACHE_KEYS.refreshDate, currentPacificDate);
            const newCount = getRefreshCount() + 1;
            localStorage.setItem(CACHE_KEYS.refreshCount, newCount.toString());
            return newCount;
        }

        function formatCacheAge(timestamp) {
            if (!timestamp) return 'Never';

            const ageMs = Date.now() - timestamp;
            const ageMinutes = Math.floor(ageMs / (1000 * 60));
            const ageHours = Math.floor(ageMs / (1000 * 60 * 60));

            if (ageMinutes < 1) return 'Just now';
            if (ageMinutes < 60) return `${ageMinutes} min ago`;
            if (ageHours < 24) return `${ageHours} hour${ageHours > 1 ? 's' : ''} ago`;
            return `${Math.floor(ageHours / 24)} day${ageHours >= 48 ? 's' : ''} ago`;
        }

        function updateCacheInfo() {
            const cacheTimeEl = document.getElementById('cache-time');
            const refreshCounterEl = document.getElementById('refresh-counter');

            const timestamp = getCacheTimestamp();
            const refreshCount = getRefreshCount();

            cacheTimeEl.textContent = `Last updated: ${formatCacheAge(timestamp)}`;
            refreshCounterEl.textContent = `Refreshes: ${refreshCount}`;
        }

        // ============================================
        // SUBSTACK CACHING SYSTEM
        // ============================================

        function saveSubstackCache(articles) {
            localStorage.setItem(CACHE_KEYS.articles, JSON.stringify(articles));
            localStorage.setItem(CACHE_KEYS.articlesTimestamp, Date.now().toString());
        }

        function loadSubstackCache() {
            const cached = localStorage.getItem(CACHE_KEYS.articles);
            return cached ? JSON.parse(cached) : null;
        }

        function isSubstackCacheValid() {
            const timestamp = localStorage.getItem(CACHE_KEYS.articlesTimestamp);
            if (!timestamp) return false;
            // Cache valid for 4 hours
            const ageHours = (Date.now() - parseInt(timestamp, 10)) / (1000 * 60 * 60);
            return ageHours < 4;
        }

        // ============================================
        // ARCHIVE SYSTEM
        // ============================================

        const ARCHIVE_MAX_AGE_DAYS = 14;

        function loadArchivedItems() {
            const stored = localStorage.getItem(CACHE_KEYS.archivedItems);
            return stored ? JSON.parse(stored) : [];
        }

        function saveArchivedItems(items) {
            localStorage.setItem(CACHE_KEYS.archivedItems, JSON.stringify(items));
        }

        function isItemArchived(itemId) {
            const archived = loadArchivedItems();
            return archived.some(item => item.id === itemId);
        }

        function archiveItem(itemId) {
            const archived = loadArchivedItems();
            
            // Check if already archived
            if (archived.some(item => item.id === itemId)) {
                return;
            }

            // Add new archived item with timestamp
            archived.push({
                id: itemId,
                archivedAt: new Date().toISOString()
            });

            saveArchivedItems(archived);

            // Gray out the card immediately and add unarchive click handler
            // Try both encoded and unencoded versions for the selector
            let card = document.querySelector(`[data-item-id="${itemId}"]`);
            if (!card) {
                card = document.querySelector(`[data-item-id="${encodeURIComponent(itemId)}"]`);
            }
            if (card) {
                card.classList.add('archived');
                // Add click handler for unarchiving
                card.onclick = function() {
                    unarchiveItem(itemId);
                };
            }
        }

        function unarchiveItem(itemId) {
            const archived = loadArchivedItems();
            const filtered = archived.filter(item => item.id !== itemId);
            saveArchivedItems(filtered);

            // Remove the archived class and onclick handler from the card
            let card = document.querySelector(`[data-item-id="${itemId}"]`);
            if (!card) {
                card = document.querySelector(`[data-item-id="${encodeURIComponent(itemId)}"]`);
            }
            if (card) {
                card.classList.remove('archived');
                card.onclick = null;  // Remove the unarchive click handler
            }
        }

        function cleanupOldArchivedItems() {
            const archived = loadArchivedItems();
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - ARCHIVE_MAX_AGE_DAYS);

            const filtered = archived.filter(item => {
                const archivedDate = new Date(item.archivedAt);
                return archivedDate > cutoffDate;
            });

            // Only save if something was actually removed
            if (filtered.length !== archived.length) {
                console.log(`Archive cleanup: removed ${archived.length - filtered.length} old items`);
                saveArchivedItems(filtered);
            }
        }

        // ============================================
        // BOOKS MANAGEMENT (localStorage)
        // ============================================

        let books = JSON.parse(localStorage.getItem('books')) || [];
        let editingIndex = null;

        function renderBooks() {
            const grid = document.getElementById('reading-grid');

            if (books.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state">
                        <p>No books added yet. Click "Add Book/Audiobook" to get started!</p>
                    </div>
                `;
                return;
            }

            grid.innerHTML = books.map((book, index) => `
                <div class="book-card" onclick="editBook(${index})">
                    <h3>${book.platform}</h3>
                    <div class="book-title">${book.title}</div>
                    <a href="${book.url}" class="book-link" target="_blank" onclick="event.stopPropagation()">
                        Open Book ‚Üí
                    </a>
                </div>
            `).join('');
        }

        function openBookModal() {
            editingIndex = null;
            document.getElementById('book-modal-title').textContent = 'Add Book/Audiobook';
            document.getElementById('bookForm').reset();
            document.getElementById('deleteBtn').style.display = 'none';
            document.getElementById('bookModal').classList.add('active');
        }

        function editBook(index) {
            editingIndex = index;
            const book = books[index];
            document.getElementById('book-modal-title').textContent = 'Edit Book/Audiobook';
            document.getElementById('platform').value = book.platform;
            document.getElementById('title').value = book.title;
            document.getElementById('url').value = book.url;
            document.getElementById('deleteBtn').style.display = 'block';
            document.getElementById('bookModal').classList.add('active');
        }

        function closeBookModal() {
            document.getElementById('bookModal').classList.remove('active');
        }

        function deleteCurrentBook() {
            if (editingIndex !== null && confirm('Are you sure you want to delete this book?')) {
                books.splice(editingIndex, 1);
                localStorage.setItem('books', JSON.stringify(books));
                closeBookModal();
                renderBooks();
            }
        }

        document.getElementById('bookForm').addEventListener('submit', function (e) {
            e.preventDefault();

            const book = {
                platform: document.getElementById('platform').value,
                title: document.getElementById('title').value,
                url: document.getElementById('url').value
            };

            if (editingIndex !== null) {
                books[editingIndex] = book;
            } else {
                books.push(book);
            }

            localStorage.setItem('books', JSON.stringify(books));
            closeBookModal();
            renderBooks();
        });

        // Close book modal when clicking outside
        document.getElementById('bookModal').addEventListener('click', function (e) {
            if (e.target === this) {
                closeBookModal();
            }
        });

        // ============================================
        // YOUTUBE INTEGRATION
        // ============================================

        // Parse ISO 8601 duration (e.g., PT1H2M10S) to total seconds
        function parseISO8601Duration(duration) {
            if (!duration) return 0;  // Guard against undefined/null
            const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
            if (!match) return 0;
            const hours = parseInt(match[1] || 0, 10);
            const minutes = parseInt(match[2] || 0, 10);
            const seconds = parseInt(match[3] || 0, 10);
            return hours * 3600 + minutes * 60 + seconds;
        }

        // Format seconds to human-readable duration (e.g., "12:34" or "1:02:15")
        function formatDuration(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function renderVideos(videos) {
            const content = document.getElementById('youtube-content');

            // Separate archived and non-archived videos
            const nonArchivedVideos = videos.filter(video => !isItemArchived(video.videoId));
            
            // Take only maxVideos non-archived items to display
            const visibleVideos = nonArchivedVideos.slice(0, CONFIG.maxVideos);

            if (visibleVideos.length === 0) {
                content.innerHTML = '<div class="empty-state"><p>No recent videos found.</p></div>';
            } else {
                content.innerHTML = `
                    <div class="content-grid">
                        ${visibleVideos.map(video => {
                            const isArchived = isItemArchived(video.videoId);
                            return `
                            <div class="content-card${isArchived ? ' archived' : ''}" 
                                 data-item-id="${video.videoId}"
                                 ${isArchived ? `onclick="unarchiveItem('${video.videoId}')"` : ''}>
                                <button class="archive-btn" onclick="archiveItem('${video.videoId}'); event.stopPropagation();" title="Archive">‚úï</button>
                                <a href="https://www.youtube.com/watch?v=${video.videoId}" target="_blank">
                                    <div class="thumbnail-container">
                                        <img src="${video.thumbnail}" alt="${video.title}">
                                        <span class="duration-badge">${video.durationFormatted}</span>
                                    </div>
                                    <div class="content-card-body">
                                        <h3>${video.title}</h3>
                                        <div class="content-meta">
                                            ${video.channelTitle} ‚Ä¢ ${formatDate(video.publishedAt)}
                                        </div>
                                    </div>
                                </a>
                            </div>
                        `}).join('')}
                    </div>
                `;
            }
        }

        async function fetchYouTubeVideos(forceRefresh = false) {
            const content = document.getElementById('youtube-content');
            const refreshBtn = document.getElementById('youtube-refresh');
            const apiKey = getApiKey();

            // Check if API key exists
            if (!apiKey) {
                content.innerHTML = `
                    <div class="empty-state">
                        <p>No YouTube API key configured.</p>
                        <button class="btn btn-primary" onclick="openApiKeyModal()">Set Up API Key</button>
                    </div>
                `;
                updateCacheInfo();
                return;
            }

            // Check cache first (unless forcing refresh)
            if (!forceRefresh && isCacheValid()) {
                const cachedVideos = loadFromCache();
                renderVideos(cachedVideos);
                updateCacheInfo();
                console.log('Loaded videos from cache');
                return;
            }

            // If cache is expired (>24h) and not forcing, auto-refresh silently
            const isAutoRefresh = !forceRefresh && getCacheAgeHours() >= CACHE_MAX_AGE_HOURS;

            refreshBtn.disabled = true;
            content.innerHTML = '<div class="loading">Loading videos...</div>';

            // Increment refresh counter BEFORE making API calls
            // (quota is consumed on request, regardless of success/failure)
            incrementRefreshCount();
            updateCacheInfo();

            try {
                // STEP 1: Fetch recent video IDs from each channel's uploads playlist
                // Cost: 1 unit per playlist (31 playlists = 31 units)
                const allVideoData = [];

                for (const playlistId of CONFIG.youtubePlaylistIds) {
                    try {
                        const response = await fetch(
                            `https://www.googleapis.com/youtube/v3/playlistItems?key=${apiKey}&playlistId=${playlistId}&part=snippet&maxResults=10`
                        );

                        if (!response.ok) {
                            const errorData = await response.json();
                            console.warn(`Playlist ${playlistId} error:`, errorData.error?.message);
                            continue; // Skip this playlist, try others
                        }

                        const data = await response.json();
                        
                        for (const item of data.items) {
                            allVideoData.push({
                                videoId: item.snippet.resourceId.videoId,
                                title: item.snippet.title,
                                thumbnail: item.snippet.thumbnails?.medium?.url || item.snippet.thumbnails?.default?.url,
                                channelTitle: item.snippet.channelTitle,
                                publishedAt: item.snippet.publishedAt
                            });
                        }
                    } catch (err) {
                        console.warn(`Error fetching playlist ${playlistId}:`, err);
                    }
                }

                // STEP 2: Batch fetch video details (duration) in groups of 50
                // Cost: 1 unit per batch (typically 1-4 batches)
                const videoIds = allVideoData.map(v => v.videoId);
                const durationMap = {};

                // Process in batches of 50
                for (let i = 0; i < videoIds.length; i += 50) {
                    const batchIds = videoIds.slice(i, i + 50);
                    const idsString = batchIds.join(',');

                    const detailsResponse = await fetch(
                        `https://www.googleapis.com/youtube/v3/videos?key=${apiKey}&id=${idsString}&part=contentDetails`
                    );

                    if (detailsResponse.ok) {
                        const detailsData = await detailsResponse.json();
                        for (const item of detailsData.items) {
                            const durationSeconds = parseISO8601Duration(item.contentDetails.duration);
                            durationMap[item.id] = durationSeconds;
                        }
                    }
                }

                // STEP 3: Merge duration data and filter out short videos (Shorts)
                // Keep videos with 0 duration (missing data) or >= minVideoDuration
                const videosWithDuration = allVideoData
                    .map(video => ({
                        ...video,
                        durationSeconds: durationMap[video.videoId] || 0,
                        durationFormatted: formatDuration(durationMap[video.videoId] || 0)
                    }))
                    .filter(video => video.durationSeconds === 0 || video.durationSeconds >= CONFIG.minVideoDuration);

                // Sort all videos by date
                videosWithDuration.sort((a, b) => new Date(b.publishedAt) - new Date(a.publishedAt));

                // Take top N videos for cache (more than we display)
                const topVideos = videosWithDuration.slice(0, CONFIG.cacheVideos);

                // Save to cache
                saveToCache(topVideos);

                renderVideos(topVideos);

                console.log(`Fetched ${allVideoData.length} videos, ${videosWithDuration.length} after filtering (>= ${CONFIG.minVideoDuration}s)`);

            } catch (error) {
                console.error('YouTube fetch error:', error);

                // Try to fall back to cache if available
                const cachedVideos = loadFromCache();
                if (cachedVideos && cachedVideos.length > 0) {
                    renderVideos(cachedVideos);
                    content.innerHTML += `
                        <div class="error" style="margin-top: 15px;">
                            <strong>Note:</strong> Showing cached data. Refresh failed: ${error.message}
                        </div>
                    `;
                } else {
                    content.innerHTML = `
                        <div class="error">
                            <strong>Error loading YouTube videos:</strong><br>
                            ${error.message}
                        </div>
                    `;
                }
            } finally {
                refreshBtn.disabled = false;
                updateCacheInfo();
            }
        }

        function refreshYouTube() {
            fetchYouTubeVideos(true);
        }

        // ============================================
        // SUBSTACK INTEGRATION
        // ============================================

        function renderSubstackArticles(articles) {
            const content = document.getElementById('substack-content');
            if (!articles || articles.length === 0) {
                content.innerHTML = '<div class="empty-state"><p>No recent articles found.</p></div>';
                return;
            }

            // Filter out archived articles and take only maxArticles
            const nonArchivedArticles = articles.filter(article => !isItemArchived(article.link));
            const visibleArticles = nonArchivedArticles.slice(0, CONFIG.maxArticles);

            if (visibleArticles.length === 0) {
                content.innerHTML = '<div class="empty-state"><p>No recent articles found.</p></div>';
                return;
            }

            content.innerHTML = `
                <div class="content-grid">
                    ${visibleArticles.map(article => {
                        // Encode the link for safe use in data attribute
                        const encodedLink = encodeURIComponent(article.link);
                        const isArchived = isItemArchived(article.link);
                        return `
                        <div class="content-card${isArchived ? ' archived' : ''}" 
                             data-item-id="${encodedLink}"
                             ${isArchived ? `onclick="unarchiveItem(decodeURIComponent('${encodedLink}'))"` : ''}>
                            <button class="archive-btn" onclick="archiveItem(decodeURIComponent('${encodedLink}')); event.stopPropagation();" title="Archive">‚úï</button>
                            <a href="${article.link}" target="_blank">
                                ${article.thumbnail ? `<img src="${article.thumbnail}" alt="${article.title}">` : ''}
                                <div class="content-card-body">
                                    <h3>${article.title}</h3>
                                    <div class="content-meta">
                                        ${article.author} ‚Ä¢ ${formatDate(article.pubDate)}
                                    </div>
                                </div>
                            </a>
                        </div>
                    `}).join('')}
                </div>
            `;
        }

        async function fetchSubstackArticles(forceRefresh = false) {
            const content = document.getElementById('substack-content');
            const refreshBtn = document.getElementById('substack-refresh');

            // Check cache first
            if (!forceRefresh && isSubstackCacheValid()) {
                const cachedArticles = loadSubstackCache();
                if (cachedArticles) {
                    renderSubstackArticles(cachedArticles);
                    console.log('Loaded Substack articles from cache');
                    return;
                }
            }

            refreshBtn.disabled = true;
            content.innerHTML = '<div class="loading">Loading articles... This may take a minute.</div>';

            try {
                const allArticles = [];
                const rssApiKey = getRssApiKey();
                // Add API key if present, otherwise no param (free tier)
                const apiKeyParam = rssApiKey ? `&api_key=${rssApiKey}` : '';

                // Fetch feeds one at a time with delays to avoid rate limiting
                for (let i = 0; i < CONFIG.substackFeeds.length; i++) {
                    const feedUrl = CONFIG.substackFeeds[i];

                    // Add a delay between requests (except for the first one)
                    if (i > 0) {
                        await new Promise(resolve => setTimeout(resolve, 500)); // 500ms delay
                    }

                    try {
                        // Use RSS2JSON service
                        const rssUrl = `${feedUrl}/feed`;
                        // Construct URL with API key if available
                        const apiUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(rssUrl)}&count=2${apiKeyParam}`;

                        const response = await fetch(apiUrl);

                        if (!response.ok) {
                            console.warn(`RSS fetch error for ${feedUrl}: ${response.status}`);
                            if (response.status === 429) {
                                console.warn('Rate limit hit! Consider adding an RSS2JSON API key in Settings.');
                            }
                            continue;
                        }

                        const data = await response.json();

                        if (data.status === 'ok' && data.items) {
                            allArticles.push(...data.items);
                        }
                    } catch (error) {
                        console.warn(`Error fetching ${feedUrl}:`, error);
                    }
                }

                // Sort all articles by date
                allArticles.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate));

                // Take top N articles for cache (more than we display)
                const topArticles = allArticles.slice(0, CONFIG.cacheArticles);

                if (topArticles.length === 0) {
                    content.innerHTML = `
                        <div class="empty-state">
                            <p>No recent articles found.</p>
                            ${!rssApiKey ? '<p style="font-size:0.9em;color:var(--text-light);margin-top:10px;">(If feeds are failing, you might need an RSS2JSON API key. Check Settings ‚öôÔ∏è)</p>' : ''}
                        </div>
                    `;
                } else {
                    // Save to cache
                    saveSubstackCache(topArticles);
                    // Render
                    renderSubstackArticles(topArticles);
                }

            } catch (error) {
                console.error('Substack fetch error:', error);

                // Fallback to cache if available
                const cached = loadSubstackCache();
                if (cached) {
                    renderSubstackArticles(cached);
                    content.innerHTML += `
                        <div class="error" style="margin-top: 15px;">
                            <strong>Note:</strong> Showing cached data. Refresh failed: ${error.message}
                        </div>
                    `;
                } else {
                    content.innerHTML = `
                        <div class="error">
                            <strong>Error loading Substack articles:</strong><br>
                            ${error.message}
                        </div>
                    `;
                }
            } finally {
                refreshBtn.disabled = false;
            }
        }

        function refreshSubstack() {
            fetchSubstackArticles(true);
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function formatDate(dateString) {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

            if (diffDays === 0) return 'Today';
            if (diffDays === 1) return 'Yesterday';
            if (diffDays < 7) return `${diffDays} days ago`;
            if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;

            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        // Clean up old archived items (older than 14 days)
        cleanupOldArchivedItems();

        // Update API key status indicator
        updateApiKeyStatus();

        // Update cache info display
        updateCacheInfo();

        // Render books on page load
        renderBooks();

        // Check if API key exists, prompt if not
        if (!getApiKey()) {
            // Show a friendly message instead of immediately popping up modal
            document.getElementById('youtube-content').innerHTML = `
                <div class="empty-state">
                    <p>Welcome! To see your YouTube feed, you'll need to set up your API key.</p>
                    <button class="btn btn-primary" onclick="openApiKeyModal()">Set Up API Key</button>
                </div>
            `;
        } else {
            // Load YouTube content (will use cache if valid, or auto-refresh if >24h old)
            fetchYouTubeVideos();
        }

        // Load Substack content (doesn't need API key)
        fetchSubstackArticles();
    </script>
</body>

</html>